Core Package Classes
####################

From the user's perspective, the main object exposed by QuTiP is the
:obj:`~qutip.Qobj` class, but this does not tell the whole story.  For the
developer, a lot of the work is done by the "data layer", which composed of
classes derived from :obj:`qutip.core.data.Data`, and operations on them.


Core Package Responsibilities
=============================

Qobj
----

:obj:`~qutip.Qobj` represents a "quantum object", be it a ket, bra, operator,
superoperator or some generalised mixture of these over a possibly composite
Hilbert space.  :obj:`~qutip.Qobj` is responsible for managing the tensor
structure of the Hilbert space, and ensuring that the requested operations make
physical sense.  It is the user-facing class, and by-and-large, the user does
not need to interact with anything lower level than it.

The actual numerical representation of the quantum object is stored in the
:attr:`~qutip.Qobj.data` field of a :obj:`~qutip.Qobj` instance, and is an
instance of a descendent of :obj:`qutip.core.data.Data`, the base of all
data-layer classes.  :obj:`~qutip.Qobj` should pass off all the actual numerical
work to the data layer, once it has made sure that the operation makes sense,
because the data layer is designed to handle operations between different
representations.


QobjEvo
-------

:obj:`~qutip.QobjEvo` represents a time-dependent quantum object.  Essentially,
it represents an object :math:`A(t)` which can be described by

.. math::
   A(t) = \sum_k f_k(t) A_k

for some scalar, time-dependent functions :math:`f_k(t)` and some time-\ 
*independent* quantum objects in compatible Hilbert spaces :math:`A_k` quantum
objects in compatible Hilbert spaces :math:`A_k`.  These :math:`A_k` will be
instances of :obj:`~qutip.Qobj`.

This class is mostly for usage in solvers and optimisers which work on
time-dependent objects, as it can transpile the scalar time-dependence down to
C code and compile this to run natively.  The classes may be instantiated
directly by users when they want to reuse the results of compilation, as this
process typically takes several seconds.

:obj:`~qutip.QobjEvo` does not store its own data, but uses the underlying
:obj:`~qutip.Qobj` instances until its :meth:`~qutip.QobjEvo.compile` method is
called.  This method produces a C extension type :obj:`~qutip.CQobjEvo`, which
*does* store its own data.


Data
----

All actual numerical data in :obj:`~qutip.Qobj` instances is stored in an
instance of :obj:`qutip.core.data.Data`, but this class itself is abstract and
does not have an instantiation mechanism.  Two of the primary examples of
concrete representations are :obj:`~qutip.core.data.Dense` and
:obj:`~qutip.core.data.CSR`, which store their data respectively as a dense
two-dimensional matrix, and a sparse matrix in compressed sparse row format.
The different formats are suited to different use-cases, but the actual
representation used should be transparent to the user, unless they want to drill
down for performance reasons.

In general, these low-level classes are implemented as CPython C extension types
written in Cython.  This is for speed reasons; most mathematical QuTiP
operations are compiled down to C++, and we can have significantly faster
overhead (and release the GIL).
