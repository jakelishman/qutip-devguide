

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Data Layer &mdash; QuTiP Developers&#39; Guide 5.0.0alpha1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script src="../_static/language_data.js"></script>
        <script async="async" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
    
    <script type="text/javascript" src="../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Documentation" href="../docs/index.html" />
    <link rel="prev" title="Quantum Objects" href="quantum-objects.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="../index.html" class="icon icon-home"> QuTiP Developers' Guide
          

          
          </a>

          
            
            
              <div class="version">
                5.0
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1 current"><a class="reference internal" href="index.html">QuTiP Package</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="development-environment.html">Creating a Development Environment</a></li>
<li class="toctree-l2"><a class="reference internal" href="quantum-objects.html">Quantum Objects</a></li>
<li class="toctree-l2 current"><a class="current reference internal" href="#">Data Layer</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#why-not-just-use-numpy">Why Not Just Use NumPy?</a></li>
<li class="toctree-l3"><a class="reference internal" href="#dispatch-operations">Dispatch Operations</a></li>
<li class="toctree-l3"><a class="reference internal" href="#type-descriptions">Type Descriptions</a><ul>
<li class="toctree-l4"><a class="reference internal" href="#abstract-base-data">Abstract Base: <code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#compressed-sparse-row-csr">Compressed Sparse Row: <code class="xref py py-obj docutils literal notranslate"><span class="pre">CSR</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="#dense-dense">Dense: <code class="xref py py-obj docutils literal notranslate"><span class="pre">Dense</span></code></a></li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../docs/index.html">Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../notebooks/index.html">Example Notebooks</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">QuTiP Developers' Guide</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../index.html">Docs</a> &raquo;</li>
        
          <li><a href="index.html">QuTiP Package</a> &raquo;</li>
        
      <li>Data Layer</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../_sources/qutip/data-layer.rst.txt" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  <div class="section" id="data-layer">
<h1>Data Layer<a class="headerlink" href="#data-layer" title="Permalink to this headline">¶</a></h1>
<p>The bulk of mathematical heavy lifting in QuTiP is handled by functions on the
“data layer”.  The term “data layer” is used to refer to all linear algebra
types which QuTiP uses to represent low-level data, operations which take place
on these types, and the dispatch logic necessary to ensure that the correct
operations are called when given two abstract types.</p>
<p>All data types on the data layer inherit from <code class="xref py py-obj docutils literal notranslate"><span class="pre">qutip.core.data.Data</span></code>,
although this is itself an abstract type which cannot be instantiated.
Dispatch functions are instances of the type <code class="xref py py-obj docutils literal notranslate"><span class="pre">qutip.core.data.Dispatch</span></code>,
which provide a Python-callable interface.</p>
<p>The data layer is primarily written in Cython, and compiled to C++ before being
compiled fully into CPython extension types.</p>
<div class="section" id="why-not-just-use-numpy">
<h2>Why Not Just Use NumPy?<a class="headerlink" href="#why-not-just-use-numpy" title="Permalink to this headline">¶</a></h2>
<p>NumPy is a fantastic tool for representing numerical data, but it is limited to
dense matrices, while many operators in quantum mechanics are often much more
suited to a sparse representation.</p>
<p>For cases which <em>are</em> well-described by dense matrices, the data-layer type
<code class="xref py py-obj docutils literal notranslate"><span class="pre">Dense</span></code> is very similar to a NumPy array underneath (and
in fact can be directly viewed as one using its
<code class="xref py py-meth docutils literal notranslate"><span class="pre">as_array()</span></code> method), but is guaranteed to hold
exactly two dimensions, of which one is stored contiguously.  These additional
internal guarantees help speed in the tightest loops, and the type can be
constructed very quickly from an <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndarray</span></code></a> that is already in the
correct format.</p>
<p>For the large number of cases where the underlying data is much sparser, we use
the <code class="xref py py-obj docutils literal notranslate"><span class="pre">qutip.core.data.CSR</span></code> type, which is a form of compressed sparse row
matrix very similar to SciPy’s <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.html#scipy.sparse.csr_matrix" title="(in SciPy v1.5.0)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">scipy.sparse.csr_matrix</span></code></a>.  There are a few
reasons for not wanting to use SciPy’s implementation:</p>
<ol class="arabic simple">
<li><p>Instantiation of <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.html#scipy.sparse.csr_matrix" title="(in SciPy v1.5.0)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">csr_matrix</span></code></a> is very slow.</p></li>
<li><p><a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.html#scipy.sparse.csr_matrix" title="(in SciPy v1.5.0)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">csr_matrix</span></code></a> can use different types as integer indices
in its index arrays, but this can make it more difficult to interface with C
code underneath.</p></li>
<li><p>QuTiP has many parts where very low-level C access is required, and having
to always deal with Python types means that we must often hold the GIL and
pay non-trivial overhead penalties when accessing Python attributes.</p></li>
</ol>
<p>Older versions of QuTiP used to reduce these issues by using a
<code class="xref py py-class docutils literal notranslate"><span class="pre">fast_csr_matrix</span></code> type which derived from
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.html#scipy.sparse.csr_matrix" title="(in SciPy v1.5.0)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">csr_matrix</span></code></a> and overrode its <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code> method to
remove the slow index-checking code and ensured that only data of the correct
types was stored.  In C-level code, a secondary struct <code class="xref c c-struct docutils literal notranslate"><span class="pre">CSR_Matrix</span></code>
was defined, which led to various parts of the code have several entry points,
depending on how many of the arguments had been converted to the structure
representation, and there was still a lot of overhead in converting back to
Python-level code at the end.</p>
<p>The new <code class="xref py py-obj docutils literal notranslate"><span class="pre">CSR</span></code> type stores data in conceptually the same
manner as SciPy, but is defined purely at the Cython level.  This means that it
pays almost no overhead when switching between Python and C access, and code
working with the types need not hold the GIL.  Further, the internal storage
makes similar guarantees to the <code class="xref py py-obj docutils literal notranslate"><span class="pre">Dense</span></code> format about the
data storage, simplifying mathematical code within QuTiP.  It can also be
viewed as a SciPy object when it needs to be used from within Python.</p>
<p>Previous versions of QuTiP also <em>only</em> supported the <code class="xref py py-class docutils literal notranslate"><span class="pre">fast_csr_matrix</span></code>
type as the backing data store.  There are many cases where this is a deeply
unsuitable type: in small systems, sparse matrices require large overheads and
stymie data caching, while even in large systems many operations produce
outputs which are nearly 100% dense such as time-evolution operators and matrix
exponentials.  For optimal control applications, the majority of the time spent
was just in dealing with the sparse overheads.  Allowing multiple types to
represent data lets us use the right tool for each job, but it does mean that
further care is taken to ensure that all the mathematical parts of the library
can function without needing to produce an exponential number of new
mathematical functions whenever a type or new operation is added.</p>
</div>
<div class="section" id="dispatch-operations">
<h2>Dispatch Operations<a class="headerlink" href="#dispatch-operations" title="Permalink to this headline">¶</a></h2>
<div class="admonition-todo admonition" id="id1">
<p class="admonition-title">Todo</p>
<p>Still to write this section, in particular there’s still some design parts
that need to be ironed out.</p>
</div>
</div>
<div class="section" id="type-descriptions">
<h2>Type Descriptions<a class="headerlink" href="#type-descriptions" title="Permalink to this headline">¶</a></h2>
<p>There are currently two first-class data types defined in QuTiP, but the
generic nature of the dispatch operations means that it is relatively
straightforward to add new types for specific use-cases.</p>
<div class="section" id="abstract-base-data">
<h3>Abstract Base: <code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code><a class="headerlink" href="#abstract-base-data" title="Permalink to this headline">¶</a></h3>
<p>The base <code class="xref py py-obj docutils literal notranslate"><span class="pre">Data</span></code> requires very little information to be
stored—only the two-dimensional shape of the matrix.  This is common to all
data types, and readable (but not writeable) from Python.</p>
</div>
<div class="section" id="compressed-sparse-row-csr">
<h3>Compressed Sparse Row: <code class="xref py py-obj docutils literal notranslate"><span class="pre">CSR</span></code><a class="headerlink" href="#compressed-sparse-row-csr" title="Permalink to this headline">¶</a></h3>
<p>The <a class="reference external" href="https://en.wikipedia.org/wiki/Sparse_matrix#Compressed_sparse_row_(CSR,_CRS_or_Yale_format)">compressed sparse row format</a> has historically always been QuTiP’s format
of choice.  Only non-zero data entries are stored, and information is kept
detailing how many stored entries are in each row, and which columns they
appear in.  This is one of the most common sparse matrix formats, having
minimal storage requirements for arbitrary sparse matrices, and perhaps most
importantly for linear algebra, it is especially suited for taking
matrix–vector products.</p>
<p>QuTiP’s implementation stores all indexing types as the centrally defined
<code class="xref c c-type docutils literal notranslate"><span class="pre">idxint</span></code> type, which is fixed at compile time.
Typically this will be a 32- or 64-bit integer, and we generally use signed
arithmetic to be consistent with Python indexing (although we do actually allow
negative indexing into C arrays).  All variables which are used to index into
an array should follow this type within C or Cython code.</p>
<p><code class="xref py py-obj docutils literal notranslate"><span class="pre">CSR</span></code> can be instantiated from Python in similar ways to
SciPy’s <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.html#scipy.sparse.csr_matrix" title="(in SciPy v1.5.0)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">csr_matrix</span></code></a>, but it also provides fast-path
initialisation from Python or C using the type’s
<code class="xref py py-meth docutils literal notranslate"><span class="pre">copy()</span></code> method, or the low-level constructors
<code class="xref py py-obj docutils literal notranslate"><span class="pre">empty</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">zeroes</span></code>,
<code class="xref py py-obj docutils literal notranslate"><span class="pre">identity</span></code>, and
<code class="xref py py-obj docutils literal notranslate"><span class="pre">copy_structure</span></code>.</p>
<div class="section" id="access-from-python">
<h4>Access From Python<a class="headerlink" href="#access-from-python" title="Permalink to this headline">¶</a></h4>
<p>We do not expose the underlying memory buffers to the user in Python space by
default.  This is to avoid needing to acquire the GIL every time one of our
objects is created, especially when C code creates several of them in a
function which otherwise would not need to speak to the Python interpreter at
all.</p>
<p>Instead, we expose a method <code class="xref py py-meth docutils literal notranslate"><span class="pre">as_scipy()</span></code>, which
returns a <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.html#scipy.sparse.csr_matrix" title="(in SciPy v1.5.0)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">csr_matrix</span></code></a>.  So that the Python-space user can
work with the data if they desire, this output is simply a “view” onto the same
underlying data buffers.  This has some memory management implications that
will be discussed in the next section.</p>
<p>The problem of <a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.html#scipy.sparse.csr_matrix" title="(in SciPy v1.5.0)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">csr_matrix</span></code></a> having a slow constructor still
persists, however.  We do not want to have to define a whole new derived class
(like the old <code class="xref py py-class docutils literal notranslate"><span class="pre">fast_csr_matrix</span></code>) just to override <code class="xref py py-meth docutils literal notranslate"><span class="pre">__init__()</span></code>,
mostly because it’s unnecessary and bloats our own code, but it also may have
annoying knock-on effects for users with imperfect polymorphic code and it adds
overhead to method resolution.  Instead, we simply allocate space for a
<a class="reference external" href="https://docs.scipy.org/doc/scipy/reference/generated/scipy.sparse.csr_matrix.html#scipy.sparse.csr_matrix" title="(in SciPy v1.5.0)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">csr_matrix</span></code></a> with its
<code class="xref py py-meth docutils literal notranslate"><span class="pre">__new__()</span></code> method, call the first reasonable
method in the initialisation chain, and fill in the rest in Cython code.
Because of the guarantees about the <code class="xref py py-obj docutils literal notranslate"><span class="pre">CSR</span></code> type, we know
that our data will already be in the correct format.</p>
<p>We then store a reference to this object within <code class="xref py py-obj docutils literal notranslate"><span class="pre">CSR</span></code> so
that subsequent calls do not need to pay the initialisation penalty.  This also
helps with memory management.</p>
</div>
<div class="section" id="memory-management">
<h4>Memory Management<a class="headerlink" href="#memory-management" title="Permalink to this headline">¶</a></h4>
<p>When constructed from Python, <code class="xref py py-obj docutils literal notranslate"><span class="pre">CSR</span></code> does not take
ownership of its memory since we know we already have to be dealing with
refcounting and the GIL.  We use NumPy’s access methods to construct new
arrays, and let NumPy handle management of the data.</p>
<p>However, when constructed from Cython code, including Cython functions called
by Python, there is no need to interface with NumPy or create Python objects
other the very last instance when we have to return it to the user in Python
space.  Here we use low-level C memory management, and rely on the general
principle of low-level QuTiP development that <em>you must not store references to
other objects’ data</em>.  Other libraries allow this, but instead require that you
suitably increment the relevant refcounts.  We do not keep track of anything
like this, and simply do not permit references in this manner within our code.
Cython operations like <code class="xref py py-meth docutils literal notranslate"><span class="pre">copy()</span></code> will always copy the
data, <em>never</em> return a view.</p>
<p>Sometimes, however, the user will need to access the data directly from Python
space.  In these cases, we must ensure that the data buffer cannot be freed
while the user holds a reference to it.  We allow the user to use the
<code class="xref py py-meth docutils literal notranslate"><span class="pre">as_scipy()</span></code> method to view the data, and as part of
this process, we create new a <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndarray</span></code></a> for each buffer, and set
the <a class="reference external" href="https://numpy.org/doc/stable/reference/c-api/array.html#c.NPY_ARRAY_OWNDATA" title="(in NumPy v1.19)"><code class="xref c c-data docutils literal notranslate"><span class="pre">NPY_ARRAY_OWNDATA</span></code></a> flag to force NumPy to manage reference
counting for us.</p>
<p>Since we have just passed on ownership of our data to another entity, we always
keep a (strong) reference to the created object within our own type.  This was
we can guarantee that NumPy will not deallocate our storage before we are done
with it, and NumPy’s memory management will also ensure that the memory <em>is</em>
deallocated safely once all Python views onto it are gone.</p>
<p>It is important when allocating buffers which may become the backing of a
<code class="xref py py-obj docutils literal notranslate"><span class="pre">CSR</span></code> type that you <em>always</em> use
<a class="reference external" href="https://numpy.org/doc/stable/reference/c-api/array.html#c.PyDataMem_NEW" title="(in NumPy v1.19)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyDataMem_NEW()</span></code></a> (or others in the <code class="docutils literal notranslate"><span class="pre">PyDataMem</span></code> family) and
<a class="reference external" href="https://numpy.org/doc/stable/reference/c-api/array.html#c.PyDataMem_FREE" title="(in NumPy v1.19)"><code class="xref c c-func docutils literal notranslate"><span class="pre">PyDataMem_FREE()</span></code></a> to allocate and free memory.  Doing
otherwise may cause segfaults or other complete interpreter crashes, as it may
not use the same allocator that NumPy does.  In particular, the Windows runtime
can easily result in this happening if raw <code class="docutils literal notranslate"><span class="pre">malloc</span></code> or <code class="docutils literal notranslate"><span class="pre">calloc</span></code> are used,
and the CPython allocator <code class="xref c c-func docutils literal notranslate"><span class="pre">cpython.mem.PyMem_Malloc()</span></code> will tend to
allocate small requests into an internal reserved buffer on its stack, which
cannot be freed from NumPy.</p>
</div>
</div>
<div class="section" id="dense-dense">
<h3>Dense: <code class="xref py py-obj docutils literal notranslate"><span class="pre">Dense</span></code><a class="headerlink" href="#dense-dense" title="Permalink to this headline">¶</a></h3>
<p>The <code class="xref py py-obj docutils literal notranslate"><span class="pre">Dense</span></code> format is the most “traditional” storage
format for linear algebra operators and vectors.  This simply explicitly stores
a value for every single element in the matrix, even if it is zero.  There is no
need to store any other information, other than the matrix’s shape, so for small
dense matrices, this can actually result in less memory usage than sparse
formats.</p>
<p>We guarantee that the data is contiguous in either row-major (C) or column-major
(Fortran) format.  This is useful in several places when interfacing with LAPACK
and BLAS functions, and generally keeps memory access fast and cache-friendly.
This is in contrast to NumPy, where taking strided views onto data can return a
new array whose memory is <em>not</em> contiguous.  NumPy makes this decision so that
strided views and slices can return faster as they do not need to copy memory,
but these operations are exceptionally rare within the QuTiP core, so we do not
optimise our data structures to support them.</p>
<div class="section" id="python-access-and-memory-management">
<h4>Python Access and Memory Management<a class="headerlink" href="#python-access-and-memory-management" title="Permalink to this headline">¶</a></h4>
<p>Similarly to <code class="xref py py-obj docutils literal notranslate"><span class="pre">CSR</span></code>, <code class="xref py py-obj docutils literal notranslate"><span class="pre">Dense</span></code> provides
the <code class="xref py py-meth docutils literal notranslate"><span class="pre">as_ndarray()</span></code> method to view its data as a NumPy
array.  This view can be used to modify the data of the object in-place.</p>
<p>As with <code class="xref py py-obj docutils literal notranslate"><span class="pre">CSR</span></code>, no Python reference is created until the
Python user specifically requests the NumPy array view.  The memory management
is handled in the same way; when instantiated from Cython code, the backing will
be a raw C pointer which is deallocated when the Python instance of
<code class="xref py py-obj docutils literal notranslate"><span class="pre">Dense</span></code> goes out-of-scope and is garbage collected.  If
the NumPy view is used, then ownership of the pointer is transferred to NumPy,
and a reference to the <a class="reference external" href="https://numpy.org/doc/stable/reference/generated/numpy.ndarray.html#numpy.ndarray" title="(in NumPy v1.19)"><code class="xref py py-obj docutils literal notranslate"><span class="pre">ndarray</span></code></a> is stored within the instance to
ensure it always outlives us.</p>
</div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="../docs/index.html" class="btn btn-neutral float-right" title="Documentation" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="quantum-objects.html" class="btn btn-neutral float-left" title="Quantum Objects" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, QuTiP developers

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>